contract HalloweenGame is Ownable, ReentrancyGuard, Pausable {
    struct MintCommit {
    uint16 amount;
    }
    struct LastWrite {
        uint64 time;
        uint64 blockNum;
    }
    // max $CANDY cost
    uint256 private maxCandyCost = 72000 ether;
    
    // number of total nfts minted so far
    uint16 public minted = 0;
    
    // address -> commit # -> commits
    mapping(address => mapping(uint16 => MintCommit)) private _mintCommits;
    // address -> commit num of commit need revealed for account
    mapping(address => uint16) private _pendingCommitId;
    // commit # -> offchain random
    mapping(uint16 => uint256) private _commitRandoms;
    uint16 private _commitId = 1;
    uint16 private pendingMintAmt;
    
    // address => can call addCommitRandom
    mapping(address => bool) private admins;

    // max number of tokens that can be minted: 60000 in production
    uint256 public maxTokens;
    // number of tokens that can be claimed for a fee: 15,000
    uint256 public PAID_TOKENS;
    // number of tokens have been minted so far
    uint16 public override minted;
    uint16 private numPumpkins;
    // mapping from tokenId to a struct containing the token's traits
    mapping(uint256 => Pumpkin) public override tokenTraits;
    // mapping from hashed(tokenTrait) to the tokenId it's associated with
    // used to ensure there are no duplicates
    mapping(uint256 => uint256) public existingCombinations;
    // Tracks the last block and timestamp that a caller has written to state.
    // Disallow some access to functions if they occur while a change is being written.
    mapping(address => LastWrite) private lastWrite;

    // list of aliases for Walker's Alias algorithm
    // 10 - 18 are associated with Pumpkins
    uint8[][18] public aliases;

constructor(uint256 _maxTokens) ERC721("Halloween Game", "HGame") {
    maxTokens = _maxTokens;
    PAID_TOKENS = _maxTokens / 4;
}
 
    /** EXTERNAL */
    // Seed the current commit id so that pending commits can be revealed
    function addCommitRandom(uint256 seed) external {
    require(owner() == _msgSender() || admins[_msgSender()], "Only admins can call this");
    _commitRandoms[_commitId] = seed;
    _commitId += 1;
    }
    
    /** Initiate the start of a mint. This action burns $CANDY, as the intent of committing is that you cannot back out once you've started.
     * This will add users into the pending queue, to be revealed after a random seed is generated and assigned to the commit id this
     * commit was added to. */
    function mintCommit(uint256 amount) external  nonReentrant {
        require(tx.origin == _msgSender(), "Only EOA");
        require(_pendingCommitId[_msgSender()] == 0, "Already have pending mints");
        uint256 maxTokens = getMaxTokens();
        require(amount > 0 && amount <= 10, "Invalid mint amount");
        
        uint256 totalCandyCost = 0;
        // Loop through the amount of
        for (uint i = 1; i <= amount; i++) {
            totalCandyCost += mintCost(pendingMintAmt + i, maxTokens);
        }
        uint16 amt = uint16(amount);
        _mintCommits[_msgSender()][_commitId] = MintCommit(amt);
        _pendingCommitId[_msgSender()] = _commitId;
        pendingMintAmt += amt;
    }
    
    /** Reveal the commits for this user. This will be when the user gets their NFT, and can only be done when the commit id that
     * the user is pending for has been assigned a random seed. */
    function mintReveal() external nonReentrant {
        require(tx.origin == _msgSender(), "Only EOA");
        reveal(_msgSender());
    }
 
    function reveal(address addr) internal {
        uint16 commitIdCur = _pendingCommitId[addr];
        require(commitIdCur > 0, "No pending commit");
        require(_commitRandoms[commitIdCur] > 0, "random seed not set");
        MintCommit memory commit = _mintCommits[addr][commitIdCur];
        pendingMintAmt -= commit.amount;
        uint16[] memory tokenIds = new uint16[](commit.amount);
        uint256 seed = _commitRandoms[commitIdCur];
        for (uint k = 0; k < commit.amount; k++) {
            minted++;
            // scramble the seed
            seed = uint256(keccak256(abi.encode(seed, addr)));
        
            tokenIds[k] = minted;
            //mint to recipient
            mint(addr, seed);
            
        }
        
        delete _mintCommits[addr][commitIdCur];
        delete _pendingCommitId[addr];
    }
    
 /**
  * @param tokenId the ID to check the cost of to mint
  * @return the cost of the given token ID
  */
    function mintCost(uint256 tokenId, uint256 maxTokens) public view returns (uint256) {
        if (tokenId <= maxTokens * 8 / 20) return 24000 ether;
        if (tokenId <= maxTokens * 11 / 20) return 36000 ether;
        if (tokenId <= maxTokens * 14 / 20) return 48000 ether;
        if (tokenId <= maxTokens * 17 / 20) return 60000 ether;
        // if (tokenId > maxTokens * 17 / 20)
        return maxCandyCost;
    }
 
   /**
   * Mint a token - any payment / game logic should be handled in the game contract.
   * This will just generate random traits and mint a token to a designated address.
   */
   function mint(address recipient, uint256 seed) external override  {
       require(admins[_msgSender()], "Only admins can call this");
       require(minted + 1 <= maxTokens, "All tokens minted");
       minted++;
       generate(minted, seed, lastWrite[tx.origin]);
       _safeMint(recipient, minted);
   }
 
   /** INTERNAL 
   * generates traits for a specific token, checking to make sure it's unique
   * @param tokenId the id of the token to generate traits for
   * @param seed a pseudorandom 256 bit number to derive traits from
   * @return t - a struct of traits for the given token ID
   */
   function generate(uint256 tokenId, uint256 seed, LastWrite memory lw) internal returns (Pumpkin memory t) {
       t = selectTraits(seed);
       if (existingCombinations[structToHash(t)] == 0) {
           tokenTraits[tokenId] = t;
           existingCombinations[structToHash(t)] = tokenId;
               numPumpkins += 1;
           }
           return t;
       }
       return generate(tokenId, random(seed, lw.time, lw.blockNum), lw);
   }
 
   /**
   * selects the species and all of its traits based on the seed value
   * @param seed a pseudorandom 256 bit number to derive traits from
   * @return t -  a struct of randomly selected traits
   */
   function selectTraits(uint256 seed) internal view returns (Pumpkin memory t) {   
        uint8 determining_number = uint8(seed) % uint8(seed * 2);

        if(determining_number <= 10000) {
            t.pumpkin_level = 10;
        } else if (determining_number > 10000 && determining_number <= 20000){
            t.pumpkin_level = 20;
        } else if (determining_number >= 30000){
            //the rarest level
            t.pumpkin_level = 30;
        }
   }
 
   //generates a pseudorandom number for picking traits. Uses point in time randomization to prevent abuse.
   function random(uint256 seed, uint64 timestamp, uint64 blockNumber) internal view returns (uint256) {
       return uint256(keccak256(abi.encodePacked(
           tx.origin,
           blockhash(blockNumber > 1 ? blockNumber - 2 : blockNumber),// Different block than HGame to ensure if needing to re-randomize that it goes down a different path
           timestamp,
           seed
       )));
   }

}

 
